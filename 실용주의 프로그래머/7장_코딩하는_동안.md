# 코딩하는 동안

## Topic 37 파충류의 뇌에 귀 기울이기

  본능이 반응하고 있음을 인지하고 왜 그런 본능이 나타나는지 알아야 한다.

### 백지의 공포

많은 사람들은 시작하는 첫 발을 두려워한다.

- 파충류의 뇌가 우리에게 무언가 할 말이 있어서
직감이 우리의 역량에 일조하도록 해야 한다.
- 실수할까봐 두렵다.

### 자신과 싸우기

코드가 보내는 피드백을 파충류의 뇌가 느끼고 있다.
코드가 무의식적으로 짜기 힘들다고 느끼거나 쉽다고 느끼면 그렇게 느껴지는 원인을 찾아봐야 한다.

### 파충류와 이야기하는 법

일단 하고 있는 일을 멈춰라. 뇌가 정리를 좀 할 수 있게 약간의 시간과 공간을 확보하라.
코드에 대한 생각 말고 키보드에서 떨어져서 잠깐 머리를 비운 채로 할 수 있는 일을 하라.

이 방법이 잘 안되면 문제를 표면으로 끄집어내 봐라. 작성하고자 하는 코드에 대한 그림을 그려보라

이러한 방법을 시도해 보았는데도 여전히 막혀있을 경우, 행동해야 할 시간이다. 
우리의 뇌에 우리가 하려는 일이 별 문제 없다고 "프로토타이핑"으로 알려줘야 한다.

### 놀이 시간이다!

이미 존게하는 코드 위에서 작업하고 있어서 기존 코드 때문에 문제 해결이 여의치 않다면 기존코드를 잠시 다른 곳으로 밀어 두고 비슷한 것을 대신 프로토타이핑으로 만들어라.
1. 포스트 잇에 프로토타이핑 중이라고 써서 모니터 옆에 붙여라
2. 프로토타이핑은 원래 실패한다고 자신에게 상기시켜라. 손해볼 일은 없다.
3. 텅 빈 에디터 화면에서 우리가 배우고 싶은 것 혹은 하고 싶은 것을 한 문장의 주석으로 표현해보라
4. 코딩을 시작하라

꺼림찍 했던 느낌이 코딩 중 갑자기 명확한 문제로 구체화 되었다면 즉각 해결하라.

실험을 끝마쳤는데도 여전히 불안한 마음이 들면 처음부터 시작하라.

이후 모든 푸로토타이핑 코드를 지우고 비워진 에디터 창에 새 코드를 작성한다.


### 여러분의 코드뿐이 아니다.

우리 일의 상당 부분은 기존 코드를 다루는 것이다.
다른 사람의 코드를 기계적으로 읽으면서 중요해 보이는 대목은 메모해 가며 시간 투자를 할 수도 있다.
처리 방식이 이상해 보이는 부분을 적어두었다가 이런 식으로 작성했어야만 하는 이유를 발견하면 코드 이해에 도움이 된다.

### 코드 뿐이 아니다

직감에 귀 기울이는 방법은 계속 갈고닦아야 할 중요한 기술이다. 설계가 왠지 이상하게 느껴질 수도 있고 어떤 요구사항이 마음을 불편하게 할 수도 있다. 하던 일을 멈추고 그 느낌을 분석하라.

## Topic 38 우연에 맡기는 프로그래밍

 의도적으로 프로그래밍 해야 한다.

### 우연에 맡기는 프로그래밍 하기

애초에 왜 코드가 돌아갈지 몰랐기 때문에 왜 코드가 망가졌는지 모른다.

### 구현에서 생기는 우연

우리가 호출한 루틴이 실제로는 그렇게 설계된 루틴이 아닌데도 우리가 원하는 효과를 내는 것처럼 보일 수 있다.

다른 사람이 호출할 코드를 작성하고 있다면 모듈화를 잘하는 것, 그리고 잘 문서화 한 적은 수의 인터페이스 아래 구현을 숨기는 것 같은 기본적인 원칙들이 모두 도움이 된다. 다른 루틴을 호출할 때도 문서화된 동작에만 의존하라.

#### 비슷하다고 괜찮을 리는 없다.

 우연이 가정과 비슷하다고 근본적인 문제를 무시해서는 안된다.

#### 유령 패턴

잘 되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.

#### 상황에서 생기는 우연

잘 되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.

#### 암묵적인 가정

X의 원인은 Y라고 가정하지 말고 중명하라，

### 의도적으로 프로그래밍 하기

- 언체나 여러분이 지금 무엇을 하고 있는지 알아야 한다.
- 더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있어야 한다.
- 자신도 잘 모르는 코드를 만들지 말라
- 계쇡을 세우고 그것을 바탕으로 진행하라
- 신뢰할 수 있는 것에만 기대라
- 가정을 기록으로 남겨라
- 코드뿐 아니라 여러분이 세운 가정도 테스트해 보아야 한다.
- 노력을 기울일 대상의 우선순위를 정하라
- 과거의 노예가 되지 말라. 기존 코드가 앞으로 깔 코드를 지배하도록 놓아 두지 말라.


## Topic 39 알고리즘의 속도

### 알고리즘을 추정한다는 말의 의미

중요한 알고리즘의 시간 복잡도는 대부분 O(n)이 아니다.

### 대분자 O 표기법 (빅오)

- O(1) : 상수 (배열의 원소 접근. 단순 명령문)
- O(lg n) : 로그 (이진 탐색) 로그의 밑은 중요하지 않다.
- O(n) : 선형(순차 검색)
- O(nlgn) : 선형보다는 좋지만, 그래도 그렇게 많이 나쁘지는 않음 - quicksort의 평균 수행 시간.
- O(n^2) : 제곱(선택 정렬과 삽입 정렬)
- O(n^3) : 세제곱
- O(c^n) : 지수 (여행하는 외판원 문제, 집합 분할 문제)

### 상식으로 추정하기

상식을 이용해서 간단한 알고리즘들의 치수를 대부분 추정할 수 있다.

### 실전에서의 알고리즘 속도 (수정)

사용하는 알고리즘의 치수를 추정하라.
코드의 실행 시간이 얼마나 될지 또는 메모리를 얼마나 사용할지 확실하지 않다면 직접 실행해 보라.

어떤 일을 하는 코드인지 코드 자체에 대해서도 생각해 보라

이런 이론적인 이야기 와중이라도 실무에서 고려할 내용 역시 놓쳐서는 안된다.

우리의 추정을 테스트하라

코드 프로파일러를 사용하여 알고리즘이 돌아갈 때 각 단계의 실행 횟수를 샌 다음 입력값 크기별 실행횟수를 그래프로 그려 보라.

### 최고라고 언제나 최고는 아니다.

적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있다.
입력 규모가 작으면 데이터를 준비하는 데 걸리는 시간이 알고리즘을 돌리는 시간보다 오히려 길어지는 일이 생기기도 한다. 이렇게 되면 이 알고리즘은 적절한 선택이 아닐 수 있다.

 성급한 최적화를 조심하라. 언제나 어떤 알고리즘을 개선하느라 시간을 투자하기 전에 그 알고리즘이 정말 병목인지 우선 확인하는 것이 좋다.

## Topic 40 리팩터링

소프트웨어 개발은 정원 가꾸기에 가깝다. 코드 고쳐쓰기, 다시 작업하기, 다시 아키텍처 만들기는 모두 아울러져서 'restructuring(재구성)'이라고 부른다. 그런데 그런 활동 중 일부를 따로 떼어 '리팩터링(refactoring)" 이라는 이 름으로 실천하기도 한다.

### 리팩터링은 언제 하는가?

우리가 무언가를 알게 되었을 때 한다. 무언가를 발견했을 때, 주저하지 말고 변경해야 한다. 발견한 그 시점이 최적기이다.

리팩터링은 고통관리를 실천하는 것이다. 

#### 현실 세계의 복잡한 문제들

 리팩터링도 문제가 작을 때, 코딩하는 동안 함꼐 진행하는 편이 쉽다.

### 리팩터링은 어떻게 하는가?

리팩터링의 본질은 재설계다. 천천히, 신중하게 조심스럽게 진행햐애 한다.
1. 리팩터링과 기능 추가를 동시에 하지 말라
2. 리팩터링을 싲가하기 전 든든한 테스트가 있는지 먼저 확인하라. 할 수 있는 한 자주 테스트를 돌려 보라.
3. 단계를 작게 나누어서 신중하게 작업하라.

탄탄한 회귀 테스트를 유지하는 것이야 말로 리팩터링의 비결이다.

일부러 코드를 꺠트려서 고쳐야 하는 부분이 어디인지 알아낼 수도 있다.

## Topic 41 테스트로 코딩하기

테스트의 주요한 이득이 테스트틀 실행할 때가 아니라 테스트에 대해 생각하고、테스트틀 작성할 때 생긴다.

### 테스트에 대해 생각하기

테스트에 대해 상각하면서 로직을 짜는데 도움이 되는 여러 발견을 할 수 있다.

### 테스트가 코딩을 주도한다.

테스트에 대해 생각함으로써 우리의 코드의 결합도는 낮추고 유연성은 올릴 수 있었다.
메서드의 테스트를 생각함으로써 코드의 작성자가 아니라 사용자인 것처럼 메서드를 외부의 시선으로 보게 되었다.


무언가를 테스트하기 좋게 만들려면 결합도도 낮아진다.

무언가를 테스트하기 위해서는 그것을 이해해야만 한다.

### 테스트 주도 개발

TDD의 기본 주기
1. 추가하고 싶은 작은 기능 하나를 결정한다
2. 그 기능이 구현되었을 때 통과하게 될 테스트를 하나 작성한다.
3. 테스트를 실행한다. 다른 테스트는 통과하고 방금 추가한 테스트 딱 하나만 실패해야 한다.
4. 실패하는 테스트를 통과시킬 수 있는 최소한의 코드만 작성한다. 그리고 이제는 모든 테스트가 통과하는지 확인한다.
5. 코드를 리팩터링한다. 방금 작성한 테스트나 함수를 개선할 수 있는 부분이 없는지 살펴본다. 개선한 후에도 테스트가 계속 통과하는지 확인한다.

TDD를 잘 사용하지만 TDD의 노예가 되지는 말아야 한다.

### 목표가 어디인지 알야야 한다.

테스트는 개발을 이끌어 나가는 데 도움이 된다. 하지단 나아갈 때 마다 목적지를 떠을리지 않으면 계속 같은 자리만 빙빙 돌게 될 수도 있다.

### 다시 코드로

 소프트웨어에서도 하드웨어 쪽 친구들과 마찬가지로
소프트웨어를 만들 때 처음부터 테스트가 가능하도록 만들고 코드를 서로 연결하기 전에 코드를 하나하나 철저하게 테스트해야 한다.
 

### 단위 테스트

### 계약을 지키는지 테스트하기

계약을 지키는지 확인하는 단위 테스트를 작성하는 것의 장점
- 코드가 계약을 지키는지 여부
- 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는지

### 임시 테스트

우리가 직접 코드를 이리저리 찔러보는 것. 디버깅 작업이 끝나면 이런 임시 테스트를 정식 테스트의 형태로 만들어 두어야 한다.

### 테스트 접점 만들기

소프트웨어를 배포한 후에도 테스트할 일이 자주 생긴다.
- 로그 파일에 쌓이는 trace 메세지
- 실행중인 코드 내부로 들어갈 수 있는 단축기 조합이나 숨겨진 url
등의 방법으로 모듈 내부의 상태를 볼 수 있다.

### 태스트 문화

소프트웨어를 철저하게 테스트할 계획을 세우는 것이 좋다.

테스트 코드를 다른 제품 코드와 마찬가지로 다뤄라. 결합도를 낮추고 깨끗하고 견고하게 유지하라.


## Topic 42 속성 기반 테스트

우리가 수의 코드를 쓰고 테스트를 작성한다면, 우리의 잘못된 가정이 코드에 들어갈 수도 있다.
테스트할 코드와 테스트를 서로 다른 사람이 작성한다. 이에 대한 대안으로 컴퓨터에게 테스트를 맡길 수도 있다.

### 계약, 불변식, 속성

코드에 존재하는 계약과 불변식을 뭉뚱그려서 '속성'이라고 한다. 코드에서 속성을 찾아내서 테스트 자동화에 사용할 수 있는데, 이것을 속성 기반 테스트라 한다.

### 테스트 데이터 생성

라이브러리를 사용해서 테스트 데이터 생성.

### 잘못된 가정 찾기

### 속성 기반 테스트는 우리를 자주 놀래킨다.

속성 기반 테스트가 강력한 이유는 그저 입력을 생성하는 규칙과 출력을 검증하는 단정문만 설정한 채 재멋대로 작동하도록 놔두기 떄문이다.

속성 기반 테스트가 실패했다면 테스트 함수가 어떤 매개 변수를 사용했는지 알아낸 다음 그 값을 이용하여 별도의 단위 테스트를 정식으로 추가하는 것이 좋다.

별도의 단위 테스트의 장점
- 여러 가지 다른 수행 결과와 상관없이 문제가 발생하는 상황에 집중할 수 있게 해준다.
- 단위 테스트가 회귀 테스트 역할을 한다. 속성 기반 테스트는 값을 랜덤 생성하기 때문에 똑같은 값을 테스트 함수에 넘긴다는 보장이 없다.

### 속성 기반 테스트는 설계에도 도움을 준다.

단위 테스트의 주요 장점중 하나는 코드에 대해 생각하게 만드는 것이다. 단위 테스트가 우리가 만드는 API의 첫 번째 고객이다.

속성 기반 테스트도 마찬가지이나, 우리가 코드를 불변식과 계약이라는 관점으로 바라보게 한다. 무엇이 변하지 않아야 하고 어떤 조건을 만족해야 하는지 생각하게 한다. 이런 관점으로 코드를 보면
- 경계 조건이 줄어든다.
- 데이터의 일관성을 해치는 함수는 더 도드라진다.



## Topic 43 바깥에서는 안전에 주의하라

우리는 지나칠 정도로 의심을 해야한다.

### 나머지 90%

 코드를 모두 작성한 상태는 90% 완료된 상태이다. 그 다음으로 코드가 잘못될 수 있는 경우를 생각해봐야 한다. 각 경우에 대한 단위 테스트를 추가하는 것이다. 내부 뿐만 아니라 외부에서 시스템을 ㅁ아가트리려 하는 시도까지도 고려해야 한다.

### 기본 보안 원칙

1. 공격 표면을 최소화하라
2. 최소 권한 원칙
3. 안전한 기본값
4. 민감 정보를 암호화하라
5. 보안 업데이트를 적용하라.

### 공격 표면을 최소화하라

1. 코드의 복잡성은 공격 매개채를 유발한다. : 복잡한 코드는 예외 상황의 발생 확률을 높히고 그 결과 공격 표면을 넓힌다.
2. 입력 데이터는 공격 매개체다. : 외부 데이터를 절대 신뢰하지 말라. 외부 데이터를 DB나 view 등에 전달하기 전에 언제나 나쁜 내용을 제거하라.
3. 인증이 없는 서비스는 공격 매개체다.
4. 인증을 요구하는 서비스도 공격 매개체다.: 인증 받은 사용자의 수를 언제나 최소로 유지하라. 쓰이지 않거나 오래되고 유효하지 않은 사용자나 서비스를 정리하라.
5. 출력 데이터는 공격 매개체이다.
6. 디버깅 정보는 공격 매개체다.

### 최소 권한 원칙

최소한의 권한만을 꼭 필요한 시간만큼 제일 짧게 부여하라는 것이 또다른 원칙이다.

### 안전한 기본값

각 사용자가 직접 보안과 편리함 사이에서 고르도록 하는 편이 낫다.

### 민감 정보를 암호화하라

개인 식별 정보, 금융 데이터, 비밀번호, 다른 인증 정보를 일반 텍스트로 남기지 말라.
설사 데이터가 유출되더라도 암호화가 안전장치 역할을 할 수 있어야 한다.

암호화나 API 키, SSH 키, 암호화 비밀번호, 그 밖의 다른 인증정보를 소스 코드용 버전 관리 시스템이 넣지 마라
보통 빌드나 배포 프로세스 내에서 설정 파일이나 환경 변수로 관리한다.

### 보안 업데이트를 적용하라


### 상식 대 암호

암호학에 있어서는 우리의 상식이 맞지 않을 수 있다는 것을 명심해야 한다.
암호화에 있어서 첫 번째 규칙이자 가장 중요한 규칙은 절대 직접 만들지 말라는 것이다.

신뢰할 수 있는 것에만 의지하지 말아야 한다. 많이 검토하고 철저하게 검사하고 잘 유지 보수되며 자주 업데이트 되는 라이브러리와 프레임워크를 사용해야 한다. 가급적 오픈 소스가 좋다.

보안 관련 기능도 주의 깊게 검토해야 한다.
비밀번호나 생체 정보를 이용한 로그인 언중을 구현하려면 해시와 슬트가 어떻계 동작하는지，해커가 레인보우 테이블같은 도구틀 어떻게 사용하는지，왜 MD5나 SHA1을 더는 쓰면 안 되는지 둥 다양한 문제틀 이해 해야 한다. 제대로 구현했다 하더라도 계속해서 데이터를 관리하고 안전하게 유지할 책임은 여전히 우리에게 있다. 새로운 법령이나 법적 의무에 대한 대응도 우리의 몫이다.

다른 사람이 대신 고민하도록 외부의 인증 서비스를 사용한다.










## Topic 44 이름 짓기

 코드에서 하는 역할에 따라 이름을 지어야 한다.
무언가를 만들 때마다 잠시 멈춰서 '내가 이것을 왜 만드는 거지?'하고 생각해야 한다.
이는 더 큰 그림을 보도록 한다.

 이름을 지을 떄는 우리가 표현하고 싶은 것을 더 명확하게 다듬기 위해 끊임없이 노력해야 한다.

### 문화를 존중하라

반복문 변수를 i, j, k로 짓는것. string형식의 변수를 s 라고 하는 것 등.
이러한 코드를 자주 마딱드릴 수 있다.

### 일관성

팀 내에서 자주 사용되는 단어의 뜻을 알고 일관성 있게 사용해야 한다.
의사소통을 장려하면 자연스럽게 의미가 퍼져나갈 것이다.

용어 사전을 만드는 것도 방법이다.

### 이름을 바꾸기는 더 어렵다.

의도를 제대로 표현하지 못하거나 오해를 부를 수 있거나 헷갈리는 이름을 발견했다면 고쳐야 한다.

잘못된 이름을 바꿀 수 없는 상황이라면 더 큰 문제가 있는것. ETC위반을 고치고 나서 잘못된 이름을 거쳐라.

