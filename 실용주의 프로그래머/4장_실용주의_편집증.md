# 4장 실용주의 편집증

누구도 완벽한 코드를 작성할 수 없음을 알기에 자신의 실수에 대비한 방어책을 마련해야 하낟.
버그 상황에서 헤어나는 도중에 어떤 손상도 입히지 않도록 보장해야 한다
이런 확인을 쉽게 해야한다. - 검증하는 코드 작성
언제나 작은 단계들을 고수해야 한다.

## Topic 23 계약에 의한 설계

소프트웨어 모듈도 서로간의 통신을 위해 계약을 사용한다.

### DBC

DBC(Designed By contract) - 계약에 의한 설계

프로그램의 정확성을 보장하기 위해 소프트웨어 모듈의 권리와 책임을 문서화하고 합의하는데 초점을 둔다.\
- 선행 조건: 루틴이 호출되기 전에 참이어야 하는 것
- 후행 조건: 루틴이 자기가 할 것이라고 보장하는 것
- 클래스 불변식: 호출자 입장에서 볼 때는 이 조건(후행 조건의 결과)이 언제나 참인 것을 클래스가 보장한다.

```
만약 호출자가 루틴의 모든 선행조건을 충족한다면 해당 루틴은 종료 시 모든 수행 조건과 불변식이 참이 되는 것을 보장한다.
```

#### 클래스 불변식과 함수형 언어

함수형 언어에서 불변식은 결과로 받는 바뀐 상태
DBC와 TDD는 별개의 개념이다. 같이 수행이 되면 더 좋다.

### DBC 구현

 코드 작성 전, 유효한 입력 범위, 경계조건, 무엇을 전달한다고 약속하는지, 약속하지 않는지 나열하는 것 만으로도 소프트웨어 설계에 엄청난 도움이 된다.

#### 단정문

단정문을 이용하면 부분적으로 컴파일러 단에서의 조건 검사를 수행할 수 있다.
하지만, 일반적인 런타임 시스템이나 라이브러리가 단정문을 통한 검사를 지원하지 않는다.

### DBC와 일찍 멈추기

단정문이나 DBC방식을 이용하면 더 일찍 멈추고 문제에 대한 보다 정확한 정보를 알려줄 수 있을 것이다.
(stack trace등을 더 타지 않아도 된다는 의미인가? - 후행 루틴에서 조건을 확인하지 않아도 된다.)

### 의미론적 불변식

고정적인 규칙 사항과 경영진이 바뀌면 사라지는 단순한 정책은 구별해야 한다.
불변식의 자격을 갖춘 요구 사항을 찾았다면 이를 우리가 작성하는 모든 문서에 잘 드러나게 작성해야 한다.
명확하고 모호한 점이 없도록 작성해야 한다.

### 동적 계약과 에이전트

고정 계약을 하는 에이전트는 모든 조건을 따라야 하나, 동적 계약 에이전트의 경우 계약을 계약을 나누는 대상과 협상할 수 있다.

## Topic 24 죽은 프로그램은 거짓말을 하지 않는다.

모든 오류는 정보를 준다.
"그럴 일이 있을 리 없어" 는 어쩌면 일어날 수 있다.

### 잡은 후 그냥 놓아주는 것은 물고기뿐

### 망치지 말고 멈춰라

 가능한 빨리 문제를 발견하면 조금 더 일찍 시스템을 멈출 수 있다.
 프로그램을 멈추는 경우가 최선인 경우가 흔하다.

## Topic 25 단정적 프로그래밍

단정문으로 불가능한 상황을 예방하라
"그럴일은 절대 없어" => 해당 상황에 대한 assert를 추가하라.

1. 하지만 진짜 오류를 처리해야 하는 곳에 단정을 대신 사용해서는 안된다.
2. assert가 프로그램을 종료시킨다고 꼭 그렇게 할 필요는 없고, assert로 인한 예외를 따로 처리해줄 수도 있다.

### 단정과 부작용

### 단정 기능을 켜 둬라

테스트가 모든 버그를 발견할 수는 없다.
실제로는 불가능해 보이는 일도 일어난다.

## Topic 26 리소스 사용의 균형

자신이 시작한 것은 자신이 끝내라
- 리소스를 할당하는 함수나 객체가 리소스를 해제한다.

지역적으로 할당하라

### 중첩할당

리소스 할당의 기본 패턴 확장, 한 번에 여러 리소스를 사용하는 루틴에 적용할 수 있다.
- 리소스를 할당한 순서의 역순으로 해제한다.
- 코드의 여러 곳에서 동일한 구성의 리소스들을 할당하는 경우에는 언제나 같은 순서로 할당해야 데드락 가능성을 줄일 수 있다.

지속적으로 균형 잡기
유한한 리소스를 사용할 때(소모할 때) 어떤것을 남기고 어떤것을 지울지 균형을 잡는 것을 고려하라

### 객체와 예외

리소스를 클래스 안에 캡슐화 하는 것이 유용할 수 있다. (중첩 클래스)
이렇게 하면 특정 유형의 리소스가 필요할 때마다 그 클래스의 객체를 생성할 수 있다.
특정 스코프를 벗어나면 클래스 내에 리소스가 수거된다.
이 접근법은 예외 때문에 리소스 해제가 제대로 되지 않을 수 있는 언어로 작업할 때에 특히 쓸모 있다.()

### 균형 잡기와 예외

예외가 던져진 경우 예외 발생 이전에 할당된 모든 것이 꺠끗이 청소된다고 어떻게 보장할 수 있을까?
1. 변수 스코프 사용 (stack 변수) - 일반적인 스코프 규칙에서는 함수나 블록종료 예외 등으로 변수가 스코프를 벗어나면 변수의 메모리가 해제된다. 소멸자에 기능을 끼워 넣을 수도 있다.
2. try-catch finally절 사용 - finally에서 리소스를 정리해줄 수 있다.

### 리소스 사용의 균형을 잡을 수 없는 경우

리소스 할당 기본 패턴이 아예 맞지 않는 경우도 존재한다. (동적인 자료구조를 사용하는 프로그램)
한 루틴에서 메모리의 일정 영역을 할당한 다음 어떤 더 큰 구조에 그것을 연결한 후, 한동안 그대로 쓰는 식
(어떤 언어일까...???)

메모리 할당에 의미론적 불변식을 정한다.
한군데 모은 자료 구조 안의 자료를 누가 책임지는지 정해 놓아야 한다.
최상위 구조의 메모리 할당을 해제할 경우 어떻게 해제할까?
- 최상위 구조가 하위 구조들을 해제할 책임을 진다. (재귀적)
- 최상위 구조가 그냥 할당 해제된다 (dangling pointer)
- 하위 구조에 리소스가 하나라도 할당 되어 있을 경우 할당 해제를 거부한다.
=> 하나를 정하고 일관성있게 구현해야 한다.

### 균형을 점검하기

일반적인 어플리케이션에서의 의미: 리소스 종류 별로 wrapper를 두고 이 래퍼들이 할당과 해제 기록을 보관한다.
(잘 와닿지는 않는데...???)

## Topic 27 헤드라이트를 앞서가지 말라

피드백을 받을 수 있는 빈도의 작업만 한번에 작업하자.
- 사용자와의 대화
- 테스트 코드 (TDD)

미래의 유지 보수도 고려해야 하지만, 우리가 예측할 수 있는 범위 내에서의 유지 보수만 고려하자.
틀릴 가능성이 높은 미래를 대비하는 것에 리소스를 많이 집어 넣는 것은 낭비가 될 확률이 높다.
그렇게 하기 보다는 코드를 쉽게 교체할 수 있도록 작성해서, 미래에 작성된 코드로 기존 코드가 교체될 수 있도록 하자.

### 블랙 스완

일반적인 예상을 뛰어넘는 아웃라이어, 그 여파는 일반적인 사건 보다 훨씬 크다.
불확실한 미래에는 예측이 가능하지 않은 블랙 스완이 등장할 수 있다.