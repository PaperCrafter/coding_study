# 구부러지거나 부러지거나

유연한 코드를 만드는 방법

## Topic 26 결합도 줄이기

좋은 설계의 핵짐 - 좋은 설계 원칙을 따르면 바꾸기 쉬운 코드를 만들 수 있다.

적게 연결하라
- 열차 사고: 연쇄 메서드 호출
- 글로벌화: 정적인 것의 위험함
- 상속: 왜 클래스 상속이 위험한가?

결함 패턴
- 관계없는 모듈이나 라이브러리 간의 희한한 의존 관계
- 한 모듈의 '간단한 수정'이 이와 관계없는 모듈을 통해 시스템 전역으로 퍼져 나가거나 시스템 다른 곳에서 무언가를 깨뜨리는 경우
- 개발자가 수정하는 부분이 시스템에 어떤 영향을 미칠지 몰라 코드의 수정을 두려워 하는 경우
- 변경 사항에 누가 영향을 받는지 파악하고 있는 사람이 없어 결국 모든 사람이 참석해야 하는 회의


### 열차 사고

기차의 모든 객차가 서로 연결되어 있듯이 메서드나 속성들이 모두 연결되어 있는 코드

#### 묻지 말고 말하라

다른 객체의 내부 상태에 따라 판단을 내리고 그 객체를 갱신해서는 안된다.
그 객체에 내부 상태에 따른 판단 및 갱신을 위임해야 한다.

### 데메테르 법칙 (Law of Demeter)

어떤 클래스 C에 정의된 메서드가 다움 목록에 속하는 것만 사용할 수 있다.
- C의 다른 인스턴스 메서드
- 메서드의 매게 변수
- 스택이나 힙에 자신이 생성하는 객체의 메서드
- 전역 변수

하지만 현실적으로 이 법칙을 사용하긴 어렵다.

#### 메서드 호출을 엮지 말라

점을 하나만 사용하도록 노력해라 (언제든지 사용하는 코드의 구현이 바뀔 수 있다.)


### 연쇠와 파이프라인

함수를 조합하여 만드는 파이프라인은 열차사고와는 다르다. (함수형 프로그래밍)
- 숨겨진 구현 세부 사항에 의존하지 않는다. (수정 시 문제가 되는 경우가 적다.)

### 글로벌화의 해악

전역 데이터의 사용을 지양하자.
싱글턴도 전역 데이터다.
수정 가능한 리소스도 전역 데이터다. (외부 포함) => 이 로소스를 작성하는 코드로 감싸야 한다.


### 상속은 결합을 늘린다

### 결국은 모두 ETC

결합된 코드는 바꾸기 힘들다. 
직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라


## Topic 29 실세계를 갖고 저글링하기

### 이벤트

어떻게 이벤트에 잘 반응하는 애플리케이션을 만들 수 있을까?
1. 유한 상태 기계 (Finite State Machine)
2. 감시자 패턴 (옵저버 패턴)
3. pub-sub
4. reactive programming 과 stream

### 유한 상태 기게

#### 실용주의 FSM 해부학

 state machine은 이벤트를 어떻게 처리할지 정의한 명세일 뿐이다.
 상태마다 그 상태일 떄 의미가 있는 이벤트를 나열하고, 이벤트별로 시스템의 다음 '현재 상태'를 정의한다.

#### 행동 추가하기

상태 전환 시에 행동을 추가한다.

#### 상태 기계는 시작일 뿐

state machine을 적용할 곳을 찾아보자.
하지만 state machine이 모든 문제를 해결하진 못한다.

### 옵저버 패턴

 감시 대상과 감시자로 이루어진다.
감시자는 관심이 있는 이벤트를 감시 대상에 등록한다.
감시 대상에 변화가 발생할 때 마다 콜백을 통해 감시자가 알 수 있다.

 모든 감시자가 감시 대상에 등록을 해야 하기 때문에 결합이 생긴다.
 감시 대상이 콜백을 직접 호출하도록 구현하기 때문에 병목이 될 수 있다.

### pub-sub

publisher와 subscriber가 있고 이들이 채널로 연결된다.
subscriber은 관심사를 하나 이상의 채널에 등록하고 publisher은 채널에 이벤트를 보낸다.
옵저버 패턴과 단리 코드 밖에서 publisher와 subscriber간의 통신이 일어난다.
비동기 이벤트 처리를 구현하기에 적합하다.

### reactive programming & Stream event

이벤트를 연결하기 위해서 stream이 필요하다. 스트림은 이벤트를 일반적인 자료 구조처럼 다룰 수 있게 한다.

이벤트 스트림은 이벤트가 발생할 때마다 채워진다.
이벤트를 발생시키는 감시 대상들을 병렬적으로 실행시킬 수 있다는 의미이다.

#### 이벤트 스트림은 비동기 컬렉션

### 어디에나 이벤트가 있다.

- 마우스 버튼 클릭
- 타이머 울림
- 로그인
- 파일의 특정 줄이 패턴과 일치

## Topic 30 변환 프로그래밍

모든 프로그램은 데이터를 변환한다.
프로그램이란 입력을 출력으로 바꾸는 것.

### 변환 찾기

입력을 출력으로 바꿔가는 단계들을 찾으면 된다. (하향식 접근)

#### 더 작은 변환들로 나누기

#### |> 연산자는 무엇이고 왜 쓰는가?

파이프 -> 함수형 프로그래밍적 관점으로 셍각하게함.

#### 계속 변환 중...

#### 이것이 왜 그리 대단한가?

변환 모델에서는 데이터를 거대한 강이자 흐름으로 생각한다.
다음 입력과 출력에만 신경을 쓰면 되어 결합을 줄일 수 있다.

### 오류 처리는 어떻게 하나?

변환 사이에 값을 날것으로 넘기지 않는다. 래퍼로 싸서 넘긴다.

#### 표현 방식 정하기

Optional 등도 좋은 wrapper가 되지 않을까...

#### 각 변환 내에서 오류 처리하기

오류가 발생하면, 오류가 파이프라인 전체의 값이 된다.

#### 파이프라인에서 오류 처리하기

함수의 호출을 나중에 호출할 수 있는 값 형태로 바꿀 수 있다.

### 변환은 프로그래밍을 변환한다.


## Topic 31 상속세

상속을 사용하는 일반적인 패턴
- 타입이 싫어서: 글자수를 줄이기 위해 사용. 공통 기능을 부모에 넣는다.
- 타입이 좋아서: 클래스 간의 관계를 상속으로 표현

### 코드를 공유하기 위해 상속을 쓸 때의 문제

상위 클래스의 구조가 변경되었을 때, 하위 클래스 역시 의도치 않게 수정이 되어 버린다.

### 타입을 정의하기 위해 상속을 쓸 대의 문제

클래스 간의 관계를 세밀한 부분까지 표현하려 노력하면 계층도는 엄청 커지게 된다.
이것은 곧 전체적인 복잡도의 증가를 의미한다.
다중 상속의 문제도 발생할 수 있다.

### 더 나은 대안

- 인터페이스와 프로토콜
- 위임
- 믹스인과 트레이스

#### 인터페이스와 프로토콜

#### 위임

상속을 하다 보면 필요없는 부분들 까지 구현읠 해줘야 할 때가 있다.
이를 다른 서비스에 위임을 해버리면 클래스를 더 가볍게 유지할 수 있다.

#### 믹스인과 트레이스

믹스인을 사용해 상황별로 테스트를 해주는 클래스를 만드는게 나은 방식이다.
믹스인: 인터페이스 등을 구현하여 프레임워크 동작 등에 사용이 될 수 있는 형태로 만드는것.

### 상속이 답인 경우는 드물다.

## Topic 32 설정

애플리케이션이 출시된 이후 바뀔 수도 있는 값에 코드가 의존하고 있다면 그 값을 애플리케이션 외부에서 관리하라.

일반적으로 설정 데이터 안에 넣는 것은 다음과 같다.
- 데이터베이스나 외부 api같은 외부 서비스의 인증 정보
- 로그 레벨과 로그 저장 위치
- 애플리케이션이 사용하는 포트 번호, IP주소, 기계나 클러스터 이름
- 특정 실행 환경에만 적용되는 검증 매개변수
- 외부에서 지정하는 매개변수, 예를 들어 운송비
- 지역에 따른 세부 서식
- 라이선스 키

### 정적 설정

설정 정보를 얇은 API 뒤로 숨기자.
세부 사항으로 부터 코드를 분리할 수 있다.

### 서비스형 설정

서비스 API 뒤에서 정적 설정이 관리되는 것을 선호한다.
서비스형 설정에는 몇 가지 장점이 있다.
- 여러 애플리케이션이 설정 정보를 공유할 수 있다. 인증과 접근 제어를 붙여서 애플리케이션 마다 보이는 정보가 다르게 만들 수도 있다.
- 여러 인스턴스에 걸쳐서 전체 설정을 한번에 바꿀 수 있다.
- 설정 데이터를 전용 UI로 관리할 수 있다.
- 설정 데이터틑 동적으로 계속 바꿀 수 있다. => 고가용 애플리케이션에서 중요

설정 정보를 바꾸기 위해 코드 빌드가 필요해서는 안된다.

### 도도 코드를 작성하지 말라

외부 설정을 사용하지 않는다면 코드는 변화하는 환경에 적응하지 못한다.
